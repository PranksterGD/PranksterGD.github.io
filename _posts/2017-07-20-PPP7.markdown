---
title: "Polish Physics - Developer's Blog 7"
layout: post
date: 2017-07-20 12:30
image:
headerImage: false
tag: 
- PPP
- blog
category: blog
author: SiddharthSuresh
description: Polish Physics
---


## Polish Physics - A Developer's Blog 7

Having build out my collision detection system, I spent the last two weeks creating the collision resolution system, which takes the list of contacts generated by the collision detection system and resolves them
iteratively.

The two main operations of the contact resolver are two update the positions and velocites of the two bodies involved in the collision.

{% highlight cpp %}
class ContactResolver
	{
	public:

		std::uint32_t mVelocityIterationsUsed;

		std::uint32_t mPositionIterationsUsed;

		void ResolveContacts(class Contact* contactArray, unsigned numContacts, Precision deltaTime);

		ContactResolver(std::uint32_t iterations, Precision velocityEpsilon = (Precision)0.01,
			Precision positionEpsilon = (Precision)0.01);

	protected:

		std::uint32_t mPositionIterations;

		std::uint32_t mVelocityIterations;

		Precision mVelocityEpsilon;

		Precision mPositionEpsilon;
		/**
		* Sets up contacts ready for processing. This makes sure their
		* internal data is configured correctly and the correct set of bodies
		* is made alive.
		*/
		void PrepareContacts(class Contact *contactArray, unsigned numContacts, Precision deltaTime);

		/**
		* Resolves the velocity issues with the given array of constraints,
		* using the given number of iterations.
		*/
		void AdjustVelocities(class Contact *contactArray, unsigned numContacts, Precision deltaTime);

		/**
		* Resolves the positional issues with the given array of constraints,
		* using the given number of iterations.
		*/
		void AdjustPositions(class Contact *contacts, unsigned numContacts, Precision deltaTime);
	};
{% endhighlight %}


{% highlight cpp %}

void ContactResolver::ResolveContacts(class Contact* contactArray, unsigned numContacts, Precision deltaTime)
{
	if (numContacts == 0)
	{
		return;
	}

	PrepareContacts(contactArray, numContacts, deltaTime);
	AdjustPositions(contactArray, numContacts, deltaTime);
	AdjustVelocities(contactArray, numContacts, deltaTime);
}
{% endhighlight %}

In addition to updating the position and velocity for the bodies involved in the collision, the contact resolver also has to check if the result of the current resolution resulted in one of these two bodies
colliding with another body. The number of iterations specifies how many times the contact resolver attempts to fix collisions caused by the result of resolutions per frame.


The result of the contact resolver looks like this.

Sphere of mass 50kg vs Cube of mass 100kg
<iframe width="640" height="480" src="../assets/videos/50v100.mp4" frameborder="0" allowfullscreen></iframe>

Sphere of mass 5kg vs Cube of mass 100kg
<iframe width="640" height="480" src="../assets/videos/5v100.mp4" frameborder="0" allowfullscreen></iframe>

Sphere of mass 0.5kg vs Cube of mass 100kg
<iframe width="640" height="480" src="../assets/videos/supersmall.mp4" frameborder="0" allowfullscreen></iframe>




The following week is going to be the last week of the project, and  I intend to build out more demos to showcase the functionality of the physics system that I've built out, as well as to potentially implement friction.

You can find the entirety of my code base on my [github](https://github.com/PranksterGD/PolishPhysics)